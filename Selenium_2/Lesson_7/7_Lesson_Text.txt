Данная тема не простая и не очень сложная, но изучив ее, вы станете магистром в поиске элементов!
XPATH (XML Path Language) - это язык запросов к элементам XML, HTML документов, и других документов класса xml.
Данный язык основывается на структуре DOM (древовидная структура) и позволяет искать элементы относительно корня, другу друга, соседей и т.д.
Мы разберем то, что я сам использую уже несколько лет и никогда не испытывал проблем с поиском элементов.

Основные символы, которые используются в XPATH-локаторах:
// - глобальный поиск относительно корня (начала) документа (обычно корень - это html тег)
/ - поиск по уровню вложенности, например когда элемент внутри элемента
P.S. Да, есть еще символ *, но он вам никогда не понадобится.

Представим, что тут мы хотим найти элемент employee, но как это сделать если он вложен в div, еще и в body?

<html class="v2" dir="ltr" lang="en">
    <head>
        <meta src="xxxxxxx"></meta>
    </head>

    <body>
        <div class="table">
            <employee id="1">
                <empid>101</empid>
                <name>David</name>
		<designation discipline="web" experience="3 year">Senior Engineer</designation>
		<email>david@myemail.com</email>
	    </employee>
         </div>
    </body>
</html>
Локатор: //employee

Тут мы нашли элемент employee глобально, от корня страницы.
Хотим получить тег name? Легко:
//name
и нам не важно как глубоко закопан это тег, так как поиск ведется глобально, относительно корня.


Представим, что нужно найти тег name, но в этот раз у нас их на странице 2.
Используя способ глобального поиска //name, мы найдем оба элемента, и как же обойти эту ситуацию, как найти именно тот name, что лежит в теге employee?

<html class="v2" dir="ltr" lang="en">
    <head>
        <meta src="xxxxxxx"></meta>
    </head>

    <body>
	<div class="table">
            <name>Alex</name>
	    <employee id="1">
	        <empid>101</empid>
	        <name>David</name>
		<designation discipline="web" experience="3 year">Senior Engineer</designation>
		<email>david@myemail.com</email>
	    </employee>
	</div>
    </body>
</html>
Решение простое, использовать прямой путь, т.е по уровню вложенности.

Локатор: //employee/name

Тут мы говорим, найди мне глобально тег employee, и уже внутри него, найди мне тег name.)

Для доступа по порядковому номеру, необходимо использовать [n], все как в Python) Но есть пара нюансов!
Допустим, у нас есть HTML-код и нам необходимо найти div с текстом 2:

<root>
    <header>
        <div>1</div>
        <div>2</div>
        <section>
            <div>3</div>
            <div>4</div>
        </section>
    </header>
</root>
Казалось бы, если мы напишем такой запрос: //header//div[2] то получим второй div внутри header, как раз который нам нужен, но нет! Мы получим "Каждый второй div лежащий внутри header"
Такой способ в изучаемом нами подходе не будет работать и врятли пригодиться, ибо нам вернуться 2 div блока, а нам нужно немного другое!
Мы напишем следующий Xpath:

(//header//div)[2]


Разобьем по частям, чтобы было понятнее:
1. (//header//div) - как вы видите стоят скобки, они вернут нам список всех div-блоков внутри header.
Пример для наглядности: (<div>1</div>, <div>2</div>, <div>3</div>, <div>4</div>)
2. (//header//div)[2] - тут мы получаем второй div из полученного списка и все работает)
Важно: индексация элементов в Xpath идет не с 0 как в Python, а с 1

Синтаксис для поиска по атрибутам выглядит следующим образом:

// элемент [ @атрибут = ’значение атрибута’ ]
Исключением является text, в нем не используется знак @, а дописываются круглые скобки, text()=’текст’, потому что это не атрибут, а параметр!

<html class="v2" dir="ltr" lang="en">
    <head>
        <meta src="xxxxxxx"></meta>
    </head>
        <body>
            <div class="table">
                <employee id="1">
                    <empid>101</empid>
                    <name>David</name>
                    <designation discipline="web" experience="3 year">Senior Engineer</designation>
                    <email>david@myemail.com</email>
                </employee>
                <employee id="2">
                    <empid>102</empid>
                    <name>John</name>
                    <designation discipline="web" experience="3 year">DBA Engineer</designation>
                    <email>john@email.com</email>
                </employee>
            </div>
    </body>
</html>
Примеры локаторов:


//div[@class=’table’] - по классу
//employee[@id=’2’] - по id
//employee[@id=’1’]/name[text()=’David’] - по тексту
//name[text()=’John’] - по тексту
и т.д

Представим, у элемента прописано несколько классов
<button class="btn btn-active">Join</button>
Еще и при этом, класс btn-active динамичный, т.е меняется из-за каких то обстоятельств.

В таком случае, если мы напишем локатор ниже

//button[@class=’btn btn-active’]
То возможно, в результате мы найдем элемент да, но если один из классов измениться, в данном случае btn-active, то ничего не выйдет.
Ну окей, тогда попробуем использовать только тот класс, который не меняется и напишем следующий локатор

//button[@class=’btn’]
Мимо, так работать не будет, так как в элементе есть еще классы… Как же быть?

Решение - это использование поиска по содержимому. Синтаксис будет выглядеть следующим образом:

//элемент [содержит (@атрибут, ‘значение содержимого’) ]
Давайте рассмотрим простой пример

<button class="btn btn-white">Join</button>
В результате получим:

//button[contains(@class, 'btn')]
А лучше вообще по тексту, что точно:

//button[contains(text(), 'Join')]

